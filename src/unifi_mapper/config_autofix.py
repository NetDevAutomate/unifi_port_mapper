#!/usr/bin/env python3
"""
Configuration Auto-Fix Module for UniFi Network Mapper.

Provides automated remediation for configuration issues detected by the
ConfigValidator, with a focus on safe, reversible operations.

Key capabilities:
- Fix tagged_vlan_mgmt: block_all on trunk/uplink ports
- Fix forward: native on trunk ports (change to forward: all)
- Enable DHCP gateway on networks
- Generate rollback scripts for all changes

This module was created after discovering that `tagged_vlan_mgmt: block_all`
combined with `forward: native` silently drops ALL tagged VLAN traffic.
"""

import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

from .config_validation import (
    Category,
    ConfigValidator,
    Severity,
    ValidationFinding,
    ValidationResult,
)

logger = logging.getLogger(__name__)


class FixStatus(Enum):
    """Status of a fix operation."""
    PENDING = "pending"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"
    DRY_RUN = "dry_run"


@dataclass
class FixResult:
    """Result of a single fix operation."""
    finding: ValidationFinding
    status: FixStatus
    message: str
    original_value: Any = None
    new_value: Any = None
    rollback_command: str = ""
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'device_name': self.finding.device_name,
            'device_id': self.finding.device_id,
            'port_idx': self.finding.port_idx,
            'issue': self.finding.title,
            'status': self.status.value,
            'message': self.message,
            'original_value': self.original_value,
            'new_value': self.new_value,
            'rollback_command': self.rollback_command,
            'error': self.error,
        }


@dataclass
class AutoFixResult:
    """Aggregated results of auto-fix operations."""
    fixes: List[FixResult] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    dry_run: bool = False

    @property
    def success_count(self) -> int:
        return sum(1 for f in self.fixes if f.status == FixStatus.SUCCESS)

    @property
    def failed_count(self) -> int:
        return sum(1 for f in self.fixes if f.status == FixStatus.FAILED)

    @property
    def skipped_count(self) -> int:
        return sum(1 for f in self.fixes if f.status == FixStatus.SKIPPED)

    @property
    def all_succeeded(self) -> bool:
        return self.failed_count == 0 and self.success_count > 0

    def add_fix(self, fix: FixResult) -> None:
        """Add a fix result."""
        self.fixes.append(fix)

    def get_rollback_script(self) -> str:
        """Generate a rollback script for all successful fixes."""
        lines = [
            "#!/usr/bin/env bash",
            "# Rollback script generated by UniFi Config Auto-Fix",
            f"# Generated: {self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "# WARNING: Review each command before executing!",
            "",
        ]

        for fix in self.fixes:
            if fix.status == FixStatus.SUCCESS and fix.rollback_command:
                lines.append(f"# Rollback: {fix.finding.title} on {fix.finding.device_name}")
                lines.append(fix.rollback_command)
                lines.append("")

        return "\n".join(lines)

    def summary(self) -> Dict[str, Any]:
        """Get summary of fix operations."""
        return {
            'timestamp': self.timestamp.isoformat(),
            'dry_run': self.dry_run,
            'total_fixes': len(self.fixes),
            'success': self.success_count,
            'failed': self.failed_count,
            'skipped': self.skipped_count,
            'all_succeeded': self.all_succeeded,
        }


class ConfigAutoFix:
    """
    Automated configuration fixer for UniFi networks.

    Integrates with ConfigValidator to detect and fix issues automatically.

    Usage:
        client = UnifiApiClient(...)
        client.login()

        fixer = ConfigAutoFix(client)

        # Dry run first
        result = fixer.fix_vlan_blocking(dry_run=True)
        print(f"Would fix {len(result.fixes)} issues")

        # Apply fixes
        result = fixer.fix_vlan_blocking(dry_run=False)
        if result.all_succeeded:
            print("All fixes applied successfully!")
    """

    # Safe values for VLAN trunk configurations
    SAFE_FORWARD_MODE = "all"
    SAFE_TAGGED_VLAN_MGMT = "auto"

    def __init__(self, api_client, site: str = "default"):
        self.api_client = api_client
        self.site = site
        self.validator = ConfigValidator(api_client, site)
        self._devices_cache: Optional[Dict] = None

    def _get_devices(self) -> Dict:
        """Get devices with caching."""
        if self._devices_cache is None:
            self._devices_cache = self.api_client.get_devices(self.site)
        return self._devices_cache

    def _clear_cache(self) -> None:
        """Clear device cache to force refresh."""
        self._devices_cache = None

    def _get_device_by_id(self, device_id: str) -> Optional[Dict]:
        """Get a specific device by ID."""
        devices = self._get_devices()
        for device in devices.get('data', []):
            if device.get('_id') == device_id:
                return device
        return None

    def _update_port_override(self, device_id: str, port_idx: int,
                              updates: Dict[str, Any], dry_run: bool = False) -> Tuple[bool, str]:
        """
        Update port override settings on a device.

        Returns (success, message) tuple.
        """
        if dry_run:
            return True, f"Would update port {port_idx}: {updates}"

        device = self._get_device_by_id(device_id)
        if not device:
            return False, f"Device {device_id} not found"

        # Get current port overrides
        port_overrides = device.get('port_overrides', [])

        # Find or create the port override entry
        port_override = None
        for po in port_overrides:
            if po.get('port_idx') == port_idx:
                port_override = po
                break

        if port_override is None:
            # Create new port override entry
            port_override = {'port_idx': port_idx}
            port_overrides.append(port_override)

        # Apply updates
        for key, value in updates.items():
            if value is None:
                # Remove the key if setting to None
                port_override.pop(key, None)
            else:
                port_override[key] = value

        # Prepare the API payload
        payload = {
            'port_overrides': port_overrides
        }

        # Make the API call
        try:
            if self.api_client.is_unifi_os:
                endpoint = f"{self.api_client.base_url}/proxy/network/api/s/{self.site}/rest/device/{device_id}"
            else:
                endpoint = f"{self.api_client.base_url}/api/s/{self.site}/rest/device/{device_id}"

            response = self.api_client.session.put(
                endpoint,
                json=payload,
                timeout=self.api_client.timeout
            )

            if response.status_code == 200:
                self._clear_cache()  # Clear cache to force refresh
                return True, f"Successfully updated port {port_idx}"
            else:
                error_msg = response.json().get('meta', {}).get('msg', 'Unknown error')
                return False, f"API error: {error_msg} (HTTP {response.status_code})"

        except Exception as e:
            return False, f"Exception: {str(e)}"

    def fix_tagged_vlan_blocking(self, dry_run: bool = False,
                                  device_filter: Optional[List[str]] = None,
                                  port_filter: Optional[List[int]] = None) -> AutoFixResult:
        """
        Fix ports with tagged_vlan_mgmt: block_all.

        This is the most common cause of VLAN traffic being silently dropped.

        Args:
            dry_run: If True, only report what would be changed
            device_filter: Optional list of device names to limit fixes to
            port_filter: Optional list of port indices to limit fixes to

        Returns:
            AutoFixResult with details of all fix operations
        """
        result = AutoFixResult(dry_run=dry_run)

        # Run validation to find issues
        validation_result = self.validator.validate_trunk_ports()

        # Find all tagged_vlan_mgmt: block_all findings
        for finding in validation_result.findings:
            if (finding.category == Category.VLAN_ROUTING and
                finding.severity == Severity.CRITICAL and
                'block_all' in str(finding.current_value).lower()):

                # Apply filters
                if device_filter and finding.device_name not in device_filter:
                    result.add_fix(FixResult(
                        finding=finding,
                        status=FixStatus.SKIPPED,
                        message=f"Device {finding.device_name} not in filter list"
                    ))
                    continue

                if port_filter and finding.port_idx not in port_filter:
                    result.add_fix(FixResult(
                        finding=finding,
                        status=FixStatus.SKIPPED,
                        message=f"Port {finding.port_idx} not in filter list"
                    ))
                    continue

                # Attempt the fix
                fix_result = self._fix_tagged_vlan_mgmt(finding, dry_run)
                result.add_fix(fix_result)

        return result

    def _fix_tagged_vlan_mgmt(self, finding: ValidationFinding,
                              dry_run: bool = False) -> FixResult:
        """Fix a single tagged_vlan_mgmt: block_all issue."""
        logger.info(f"{'[DRY RUN] ' if dry_run else ''}Fixing tagged_vlan_mgmt on "
                   f"{finding.device_name} port {finding.port_idx}")

        # The fix: remove tagged_vlan_mgmt or set to auto
        updates = {
            'tagged_vlan_mgmt': None  # Remove the setting entirely
        }

        success, message = self._update_port_override(
            finding.device_id,
            finding.port_idx,
            updates,
            dry_run
        )

        if dry_run:
            return FixResult(
                finding=finding,
                status=FixStatus.DRY_RUN,
                message=f"Would remove tagged_vlan_mgmt: block_all from port {finding.port_idx}",
                original_value="block_all",
                new_value="(removed)",
                rollback_command=self._generate_rollback_cmd(
                    finding.device_id, finding.port_idx,
                    'tagged_vlan_mgmt', 'block_all'
                )
            )

        if success:
            return FixResult(
                finding=finding,
                status=FixStatus.SUCCESS,
                message=message,
                original_value="block_all",
                new_value="(removed)",
                rollback_command=self._generate_rollback_cmd(
                    finding.device_id, finding.port_idx,
                    'tagged_vlan_mgmt', 'block_all'
                )
            )
        else:
            return FixResult(
                finding=finding,
                status=FixStatus.FAILED,
                message=message,
                error=message
            )

    def fix_forward_native(self, dry_run: bool = False,
                           device_filter: Optional[List[str]] = None,
                           port_filter: Optional[List[int]] = None) -> AutoFixResult:
        """
        Fix ports with forward: native on trunk/uplink ports.

        Changes forward mode from 'native' to 'all' to allow tagged VLAN traffic.

        Args:
            dry_run: If True, only report what would be changed
            device_filter: Optional list of device names to limit fixes to
            port_filter: Optional list of port indices to limit fixes to

        Returns:
            AutoFixResult with details of all fix operations
        """
        result = AutoFixResult(dry_run=dry_run)

        # Run validation to find issues
        validation_result = self.validator.validate_trunk_ports()

        # Find all forward: native findings
        for finding in validation_result.findings:
            if (finding.category == Category.VLAN_ROUTING and
                finding.severity == Severity.CRITICAL and
                'forward' in str(finding.current_value).lower() and
                'native' in str(finding.current_value).lower()):

                # Apply filters
                if device_filter and finding.device_name not in device_filter:
                    result.add_fix(FixResult(
                        finding=finding,
                        status=FixStatus.SKIPPED,
                        message=f"Device {finding.device_name} not in filter list"
                    ))
                    continue

                if port_filter and finding.port_idx not in port_filter:
                    result.add_fix(FixResult(
                        finding=finding,
                        status=FixStatus.SKIPPED,
                        message=f"Port {finding.port_idx} not in filter list"
                    ))
                    continue

                # Attempt the fix
                fix_result = self._fix_forward_native(finding, dry_run)
                result.add_fix(fix_result)

        return result

    def _fix_forward_native(self, finding: ValidationFinding,
                            dry_run: bool = False) -> FixResult:
        """Fix a single forward: native issue."""
        logger.info(f"{'[DRY RUN] ' if dry_run else ''}Fixing forward: native on "
                   f"{finding.device_name} port {finding.port_idx}")

        # The fix: change forward to 'all'
        updates = {
            'forward': self.SAFE_FORWARD_MODE
        }

        success, message = self._update_port_override(
            finding.device_id,
            finding.port_idx,
            updates,
            dry_run
        )

        if dry_run:
            return FixResult(
                finding=finding,
                status=FixStatus.DRY_RUN,
                message=f"Would change forward from 'native' to 'all' on port {finding.port_idx}",
                original_value="native",
                new_value="all",
                rollback_command=self._generate_rollback_cmd(
                    finding.device_id, finding.port_idx,
                    'forward', 'native'
                )
            )

        if success:
            return FixResult(
                finding=finding,
                status=FixStatus.SUCCESS,
                message=message,
                original_value="native",
                new_value="all",
                rollback_command=self._generate_rollback_cmd(
                    finding.device_id, finding.port_idx,
                    'forward', 'native'
                )
            )
        else:
            return FixResult(
                finding=finding,
                status=FixStatus.FAILED,
                message=message,
                error=message
            )

    def fix_all_vlan_blocking(self, dry_run: bool = False,
                              device_filter: Optional[List[str]] = None,
                              port_filter: Optional[List[int]] = None) -> AutoFixResult:
        """
        Fix all VLAN blocking issues (both tagged_vlan_mgmt and forward: native).

        This is the comprehensive fix for VLAN routing problems.

        Args:
            dry_run: If True, only report what would be changed
            device_filter: Optional list of device names to limit fixes to
            port_filter: Optional list of port indices to limit fixes to

        Returns:
            AutoFixResult with details of all fix operations
        """
        result = AutoFixResult(dry_run=dry_run)

        # Fix tagged_vlan_mgmt: block_all issues
        block_all_result = self.fix_tagged_vlan_blocking(dry_run, device_filter, port_filter)
        result.fixes.extend(block_all_result.fixes)

        # Fix forward: native issues
        forward_native_result = self.fix_forward_native(dry_run, device_filter, port_filter)
        result.fixes.extend(forward_native_result.fixes)

        return result

    def _generate_rollback_cmd(self, device_id: str, port_idx: int,
                               setting: str, original_value: str) -> str:
        """Generate a rollback command/note for a fix."""
        return (
            f"# To rollback: Set {setting}={original_value} on device {device_id} port {port_idx}\n"
            f"# Use: unifi-config-autofix --device-id {device_id} --port {port_idx} "
            f"--set {setting}={original_value}"
        )

    def generate_report(self, result: AutoFixResult, format: str = "text") -> str:
        """Generate a report of fix operations."""
        if format == "json":
            return json.dumps({
                'summary': result.summary(),
                'fixes': [f.to_dict() for f in result.fixes]
            }, indent=2)

        elif format == "markdown":
            return self._generate_markdown_report(result)

        else:
            return self._generate_text_report(result)

    def _generate_text_report(self, result: AutoFixResult) -> str:
        """Generate text report."""
        lines = [
            "",
            "=" * 60,
            "UNIFI CONFIG AUTO-FIX RESULTS",
            "=" * 60,
            f"Timestamp: {result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}",
            f"Mode: {'DRY RUN' if result.dry_run else 'LIVE'}",
            "",
            f"Total fixes: {len(result.fixes)}",
            f"  âœ… Success: {result.success_count}",
            f"  âŒ Failed: {result.failed_count}",
            f"  â­ï¸ Skipped: {result.skipped_count}",
            "",
        ]

        # Group by status
        for status in [FixStatus.SUCCESS, FixStatus.FAILED, FixStatus.SKIPPED, FixStatus.DRY_RUN]:
            fixes = [f for f in result.fixes if f.status == status]
            if not fixes:
                continue

            status_emoji = {
                FixStatus.SUCCESS: "âœ…",
                FixStatus.FAILED: "âŒ",
                FixStatus.SKIPPED: "â­ï¸",
                FixStatus.DRY_RUN: "ğŸ”",
            }[status]

            lines.append(f"{status_emoji} {status.value.upper()} ({len(fixes)}):")
            lines.append("-" * 40)

            for fix in fixes:
                lines.append(f"  â€¢ {fix.finding.device_name} port {fix.finding.port_idx}")
                lines.append(f"    Issue: {fix.finding.title}")
                lines.append(f"    {fix.message}")
                if fix.original_value and fix.new_value:
                    lines.append(f"    Changed: {fix.original_value} â†’ {fix.new_value}")
                if fix.error:
                    lines.append(f"    Error: {fix.error}")
                lines.append("")

        return "\n".join(lines)

    def _generate_markdown_report(self, result: AutoFixResult) -> str:
        """Generate markdown report."""
        lines = [
            "# UniFi Config Auto-Fix Report",
            "",
            f"**Generated**: {result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}",
            f"**Mode**: {'DRY RUN' if result.dry_run else 'LIVE'}",
            "",
            "## Summary",
            "",
            "| Metric | Value |",
            "|--------|-------|",
            f"| Total Fixes | {len(result.fixes)} |",
            f"| âœ… Success | {result.success_count} |",
            f"| âŒ Failed | {result.failed_count} |",
            f"| â­ï¸ Skipped | {result.skipped_count} |",
            "",
            "## Details",
            "",
        ]

        for fix in result.fixes:
            status_emoji = {
                FixStatus.SUCCESS: "âœ…",
                FixStatus.FAILED: "âŒ",
                FixStatus.SKIPPED: "â­ï¸",
                FixStatus.DRY_RUN: "ğŸ”",
                FixStatus.PENDING: "â³",
            }[fix.status]

            lines.append(f"### {status_emoji} {fix.finding.device_name} - Port {fix.finding.port_idx}")
            lines.append("")
            lines.append(f"- **Issue**: {fix.finding.title}")
            lines.append(f"- **Status**: {fix.status.value}")
            lines.append(f"- **Message**: {fix.message}")

            if fix.original_value and fix.new_value:
                lines.append(f"- **Changed**: `{fix.original_value}` â†’ `{fix.new_value}`")

            if fix.error:
                lines.append(f"- **Error**: {fix.error}")

            lines.append("")

        if result.success_count > 0 and not result.dry_run:
            lines.append("## Rollback Script")
            lines.append("")
            lines.append("```bash")
            lines.append(result.get_rollback_script())
            lines.append("```")

        return "\n".join(lines)
